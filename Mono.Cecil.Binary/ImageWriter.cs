/*
 * Copyright (c) 2004, 2005 DotNetGuru and the individuals listed
 * on the ChangeLog entries.
 *
 * Authors :
 *   Jb Evain   (jbevain@gmail.com)
 *
 * This is a free software distributed under a MIT/X11 license
 * See LICENSE.MIT file for more details
 *
 * Generated by /CodeGen/cecil-gen.rb do not edit
 * Sun Aug 07 18:06:33 CEST 2005
 *
 *****************************************************************************/

namespace Mono.Cecil.Binary {

	using System;
	using System.IO;
	using System.Text;

	using Mono.Cecil;
	using Mono.Cecil.Metadata;

	internal sealed class ImageWriter : BaseImageVisitor {

		private Image m_img;
		private BinaryWriter m_binaryWriter;

		private BinaryWriter m_textWriter;
		private BinaryWriter m_relocWriter;

		public ImageWriter (MetadataWriter writer, BinaryWriter bw)
		{
			m_img = writer.GetMetadataRoot ().GetImage ();
			m_binaryWriter = bw;

			m_textWriter = new BinaryWriter (new MemoryStream ());
			m_textWriter.BaseStream.Position = 80;
			m_relocWriter = new BinaryWriter (new MemoryStream ());
		}

		public Image GetImage ()
		{
			return m_img;
		}

		public BinaryWriter GetTextWriter ()
		{
			return m_textWriter;
		}

		public uint GetAligned (uint integer, uint alignWith)
		{
			return (integer + alignWith - 1) & ~(alignWith - 1);
		}

		public override void Visit (Image img)
		{
			uint imgBase = img.PEOptionalHeader.NTSpecificFields.ImageBase;
			uint sectAlign = img.PEOptionalHeader.NTSpecificFields.SectionAlignment;
			uint fileAlign = img.PEOptionalHeader.NTSpecificFields.FileAlignment;

			Section txtSec = img.TextSection;
			Section relocSec = null;
			foreach (Section s in img.Sections)
				if (s.Name == Section.Relocs)
					relocSec = s;

			txtSec.VirtualSize = (uint) m_textWriter.BaseStream.Length;
			relocSec.VirtualSize = (uint) m_relocWriter.BaseStream.Length;

			// size computations, fields setting, etc.
			uint nbSects = (uint) img.Sections.Count;
			img.PEFileHeader.NumberOfSections = (ushort) nbSects;

			// build the reloc section data
			uint relocSize = 12;
			m_relocWriter.Write ((uint) 0x200);
			m_relocWriter.Write (relocSize);
			m_relocWriter.Write ((ushort) (3 << relocSize) + 2);
			m_relocWriter.Write ((ushort) 0);

			// start counting before sections headers
			// section start + section header sixe * number of sections
			uint headersEnd = 0x178 + 0x28 * nbSects;
			uint fileOffset = headersEnd;
			uint sectOffset = sectAlign;
			uint imageSize = 0;

			foreach (Section sect in img.Sections) {
				fileOffset = GetAligned (fileOffset, fileAlign);
				sectOffset = GetAligned (sectOffset, sectAlign);

				sect.PointerToRawData = fileOffset;
				sect.VirtualAddress = new RVA (sectOffset);
				sect.SizeOfRawData = GetAligned (sect.VirtualSize, fileAlign);

				fileOffset += sect.SizeOfRawData;
				sectOffset += sect.SizeOfRawData;
				imageSize += GetAligned (sect.SizeOfRawData, sectAlign);
			}

			if (txtSec.VirtualAddress.Value != 0x2000)
				throw new ImageFormatException ("Wrong RVA for .text section");

			img.PEOptionalHeader.StandardFields.CodeSize = GetAligned (
				txtSec.SizeOfRawData, fileAlign);
			img.PEOptionalHeader.StandardFields.BaseOfCode = txtSec.VirtualAddress;

			// entry point rva

			imageSize += headersEnd;
			img.PEOptionalHeader.NTSpecificFields.ImageSize = GetAligned (imageSize, sectAlign);
		}

		public override void Visit (DOSHeader header)
		{
			m_binaryWriter.Write (header.Start);
			m_binaryWriter.Write (header.Lfanew);
			m_binaryWriter.Write (header.End);

			m_binaryWriter.Write ((ushort) 0x4550);
			m_binaryWriter.Write ((ushort) 0);
		}

		public override void Visit (PEFileHeader header)
		{
			m_binaryWriter.Write (header.Machine);
			m_binaryWriter.Write (header.NumberOfSections);
			m_binaryWriter.Write (header.TimeDateStamp);
			m_binaryWriter.Write (header.PointerToSymbolTable);
			m_binaryWriter.Write (header.NumberOfSymbols);
			m_binaryWriter.Write (header.OptionalHeaderSize);
			m_binaryWriter.Write ((ushort) header.Characteristics);
		}

		public override void Visit (PEOptionalHeader.NTSpecificFieldsHeader header)
		{
			m_binaryWriter.Write (header.ImageBase);
			m_binaryWriter.Write (header.SectionAlignment);
			m_binaryWriter.Write (header.FileAlignment);
			m_binaryWriter.Write (header.OSMajor);
			m_binaryWriter.Write (header.OSMinor);
			m_binaryWriter.Write (header.UserMajor);
			m_binaryWriter.Write (header.UserMinor);
			m_binaryWriter.Write (header.SubSysMajor);
			m_binaryWriter.Write (header.SubSysMinor);
			m_binaryWriter.Write (header.Reserved);
			m_binaryWriter.Write (header.ImageSize);
			m_binaryWriter.Write (header.HeaderSize);
			m_binaryWriter.Write (header.FileChecksum);
			m_binaryWriter.Write ((ushort) header.SubSystem);
			m_binaryWriter.Write (header.DLLFlags);
			m_binaryWriter.Write (header.StackReserveSize);
			m_binaryWriter.Write (header.StackCommitSize);
			m_binaryWriter.Write (header.HeapReserveSize);
			m_binaryWriter.Write (header.HeapCommitSize);
			m_binaryWriter.Write (header.LoaderFlags);
			m_binaryWriter.Write (header.NumberOfDataDir);
		}

		public override void Visit (PEOptionalHeader.StandardFieldsHeader header)
		{
			m_binaryWriter.Write (header.Magic);
			m_binaryWriter.Write (header.LMajor);
			m_binaryWriter.Write (header.LMinor);
			m_binaryWriter.Write (header.CodeSize);
			m_binaryWriter.Write (header.InitializedDataSize);
			m_binaryWriter.Write (header.UninitializedDataSize);
			m_binaryWriter.Write (header.EntryPointRVA.Value);
			m_binaryWriter.Write (header.BaseOfCode.Value);
			m_binaryWriter.Write (header.BaseOfData.Value);
		}

		public override void Visit (PEOptionalHeader.DataDirectoriesHeader header)
		{
			m_binaryWriter.Write (header.ExportTable.VirtualAddress);
			m_binaryWriter.Write (header.ExportTable.Size);
			m_binaryWriter.Write (header.ImportTable.VirtualAddress);
			m_binaryWriter.Write (header.ImportTable.Size);
			m_binaryWriter.Write (header.ResourceTable.VirtualAddress);
			m_binaryWriter.Write (header.ResourceTable.Size);
			m_binaryWriter.Write (header.ExceptionTable.VirtualAddress);
			m_binaryWriter.Write (header.ExceptionTable.Size);
			m_binaryWriter.Write (header.CertificateTable.VirtualAddress);
			m_binaryWriter.Write (header.CertificateTable.Size);
			m_binaryWriter.Write (header.BaseRelocationTable.VirtualAddress);
			m_binaryWriter.Write (header.BaseRelocationTable.Size);
			m_binaryWriter.Write (header.Debug.VirtualAddress);
			m_binaryWriter.Write (header.Debug.Size);
			m_binaryWriter.Write (header.Copyright.VirtualAddress);
			m_binaryWriter.Write (header.Copyright.Size);
			m_binaryWriter.Write (header.GlobalPtr.VirtualAddress);
			m_binaryWriter.Write (header.GlobalPtr.Size);
			m_binaryWriter.Write (header.TLSTable.VirtualAddress);
			m_binaryWriter.Write (header.TLSTable.Size);
			m_binaryWriter.Write (header.LoadConfigTable.VirtualAddress);
			m_binaryWriter.Write (header.LoadConfigTable.Size);
			m_binaryWriter.Write (header.BoundImport.VirtualAddress);
			m_binaryWriter.Write (header.BoundImport.Size);
			m_binaryWriter.Write (header.IAT.VirtualAddress);
			m_binaryWriter.Write (header.IAT.Size);
			m_binaryWriter.Write (header.DelayImportDescriptor.VirtualAddress);
			m_binaryWriter.Write (header.DelayImportDescriptor.Size);
			m_binaryWriter.Write (header.CLIHeader.VirtualAddress);
			m_binaryWriter.Write (header.CLIHeader.Size);
			m_binaryWriter.Write (header.Reserved.VirtualAddress);
			m_binaryWriter.Write (header.Reserved.Size);
		}


		public override void Visit (Section sect)
		{
			m_binaryWriter.Write (sect.Name);
			int more = 8 - sect.Name.Length;
			for (int i = 0; i < more; i++)
				m_binaryWriter.Write ((byte) 0);

			m_binaryWriter.Write (sect.VirtualSize);
			m_binaryWriter.Write (sect.VirtualAddress.Value);
			m_binaryWriter.Write (sect.SizeOfRawData);
			m_binaryWriter.Write (sect.PointerToRawData.Value);
			m_binaryWriter.Write (sect.PointerToRelocations.Value);
			m_binaryWriter.Write (sect.PointerToLineNumbers.Value);
			m_binaryWriter.Write (sect.NumberOfRelocations);
			m_binaryWriter.Write (sect.NumberOfLineNumbers);
			m_binaryWriter.Write ((uint) sect.Characteristics);
		}

		public override void Visit (ImportAddressTable iat)
		{
			m_textWriter.Write (iat.HintNameTableRVA.Value);
		}

		public override void Visit (CLIHeader header)
		{
			m_textWriter.Write (header.Cb);
			m_textWriter.Write (header.MajorRuntimeVersion);
			m_textWriter.Write (header.MinorRuntimeVersion);
			m_textWriter.Write (header.Metadata.VirtualAddress);
			m_textWriter.Write (header.Metadata.Size);
			m_textWriter.Write ((uint) header.Flags);
			m_textWriter.Write (header.EntryPointToken);
			m_textWriter.Write (header.Resources.VirtualAddress);
			m_textWriter.Write (header.Resources.Size);
			m_textWriter.Write (header.StrongNameSignature.VirtualAddress);
			m_textWriter.Write (header.StrongNameSignature.Size);
			m_textWriter.Write (header.CodeManagerTable.VirtualAddress);
			m_textWriter.Write (header.CodeManagerTable.Size);
			m_textWriter.Write (header.VTableFixups.VirtualAddress);
			m_textWriter.Write (header.VTableFixups.Size);
			m_textWriter.Write (header.ExportAddressTableJumps.VirtualAddress);
			m_textWriter.Write (header.ExportAddressTableJumps.Size);
			m_textWriter.Write (header.ManagedNativeHeader.VirtualAddress);
			m_textWriter.Write (header.ManagedNativeHeader.Size);
		}

		public override void Visit (ImportTable it)
		{
			m_textWriter.Write (it.ImportAddressTable.Value);
			m_textWriter.Write (it.DateTimeStamp);
			m_textWriter.Write (it.ForwardChain);
			m_textWriter.Write (it.Name.Value);
			m_textWriter.Write (it.ImportAddressTable.Value);
		}

		public override void Visit (ImportLookupTable ilt)
		{
			m_textWriter.Write (ilt.HintNameRVA.Value);
		}

		public override void Visit (HintNameTable hnt)
		{
			m_textWriter.Write (hnt.Hint);
			m_textWriter.Write (hnt.RuntimeMain);
			m_textWriter.Write ('\0');
			m_textWriter.Write (hnt.RuntimeLibrary);
			m_textWriter.Write ('\0');

			m_textWriter.Write (hnt.EntryPoint);
			m_textWriter.Write (hnt.RVA);
		}

		public override void Terminate (Image img)
		{
			// write sections, align the whole thing
		}
	}
}
